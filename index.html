<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Buraco Negro Realista Mobile</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #container { width: 100vw; height: 100vh; display: block; }
        #info {
            position: absolute; top: 0; left: 0; width: 100%;
            padding: 10px 0; color: rgba(255, 255, 255, 0.7); 
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            text-align: center; pointer-events: none; z-index: 10;
        }
        #info h1 { font-size: 1rem; margin: 0; text-transform: uppercase; letter-spacing: 2px; }
        #info p { font-size: 0.7rem; margin: 2px 0; }
    </style>
</head>
<body>
    <div id="info">
        <h1>Gargantua Mobile</h1>
        <p>1 Dedo: Girar • 2 Dedos: Zoom (Pinça)</p>
    </div>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- VARIÁVEIS GLOBAIS ---
        let scene, camera, renderer, material;
        
        // Controle de Câmera
        let camDist = 18.0; // Distância inicial (mais longe para caber na tela)
        let camLat = -0.2;  // Inclinação inicial
        let camLon = 1.5;   // Rotação inicial
        
        // Variáveis de Toque
        let lastX = 0, lastY = 0;
        let lastDist = 0; // Para o zoom
        let isDragging = false;
        let isZooming = false;

        // --- GLSL SHADERS (O cérebro da simulação) ---

        const vertexShader = `
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            precision mediump float; // Essencial para Moto e22

            uniform float time;
            uniform vec2 resolution;
            uniform vec3 camPos;     // Posição calculada no JS
            uniform vec3 camTarget;  // Para onde a câmera olha (0,0,0)

            // Configurações de Qualidade
            #define MAX_STEPS 35     // Aumentei um pouco para melhorar o disco
            #define MAX_DIST 50.0
            
            // Função de Rotação 2D
            mat2 rot(float a) {
                float s = sin(a), c = cos(a);
                return mat2(c, -s, s, c);
            }

            // --- FUNÇÕES DO DISCO DE ACREÇÃO ---
            
            // Gera um padrão de ruído barato (sem textura)
            float noise(vec3 p) {
                float n = sin(p.x * 5.0 + time * 2.0) * sin(p.z * 5.0);
                return n * 0.5 + 0.5;
            }

            vec3 getDiskColor(vec3 p, float distToCenter) {
                // Definição do tamanho do disco
                if(distToCenter < 1.5 || distToCenter > 6.5) return vec3(0.0);

                // Ângulo para mapear a textura ao redor do buraco
                float angle = atan(p.z, p.x);
                
                // --- Efeito Doppler (Realismo) ---
                // O lado que gira na nossa direção (esquerda da tela geralmente) fica azul/branco
                // O lado que se afasta fica vermelho/escuro.
                // Simulamos isso pegando o seno do angulo relativo à câmera.
                float doppler = sin(angle + 1.0) * 0.5 + 0.5; // +1.0 é um ajuste de fase
                
                // Turbulência (Plasma girando)
                // A velocidade aumenta perto do centro (distToCenter)
                float speed = time * (10.0 / distToCenter);
                float turbulence = sin(angle * 10.0 + speed) * cos(distToCenter * 5.0);
                turbulence = turbulence * 0.5 + 0.5;

                // Cor Base (Gradiente de Temperatura)
                // Perto do centro = Branco/Azul (Quente)
                // Longe = Laranja/Vermelho (Frio)
                vec3 hotColor = vec3(0.8, 0.9, 1.0); // Azulado
                vec3 coldColor = vec3(1.0, 0.2, 0.05); // Laranja avermelhado
                
                float temp = 1.0 - smoothstep(1.5, 6.0, distToCenter);
                vec3 finalColor = mix(coldColor, hotColor, temp * temp);

                // Aplica turbulência e Doppler
                float brightness = temp * turbulence;
                
                // O Doppler deixa um lado muito mais brilhante (beaming)
                brightness *= (0.5 + doppler * 2.0); 

                return finalColor * brightness * 2.0;
            }

            void main() {
                // Normaliza coordenadas da tela
                vec2 uv = (gl_FragCoord.xy - 0.5 * resolution.xy) / resolution.y;

                // Configura Câmera (LookAt simples)
                vec3 ro = camPos;
                vec3 fwd = normalize(camTarget - ro);
                vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), fwd));
                vec3 up = cross(fwd, right);
                vec3 rd = normalize(fwd + right * uv.x + up * uv.y);

                // Raymarching
                vec3 col = vec3(0.0);
                vec3 p = ro;
                float t = 0.0;
                
                // Acumulador de brilho do disco
                vec3 accDisk = vec3(0.0);

                for(int i = 0; i < MAX_STEPS; i++) {
                    p = ro + rd * t;
                    float r = length(p);

                    // 1. Gravidade (Bending Light)
                    // Desvia a luz em direção ao centro
                    if (r > 1.0) {
                        // Força da gravidade simplificada
                        float force = 0.15 / (r * r); 
                        rd = normalize(rd - p * force * 0.1); 
                    }

                    // 2. Detecção do Disco de Acreção
                    // O disco está no plano Y=0. Se o raio passa perto de Y=0...
                    if(abs(p.y) < 0.3) {
                        float distXZ = length(p.xz);
                        if(distXZ > 1.4 && distXZ < 7.0) {
                             // Calcula a cor neste ponto
                             vec3 diskSample = getDiskColor(p, distXZ);
                             
                             // Adiciona ao acumulador (efeito de brilho/glow)
                             // Quanto mais longe do centro, mais transparente
                             float transparency = 0.15; 
                             accDisk += diskSample * transparency;
                        }
                    }

                    // Passo variável (avança rápido longe, devagar perto)
                    float dt = max(0.1, r * 0.15);
                    t += dt;

                    // Horizonte de Eventos (O Buraco Negro)
                    if(r < 1.0) {
                        col = vec3(0.0); // Absorve tudo (Preto)
                        break;
                    }
                    
                    // Se foi muito longe, sai do loop
                    if(t > MAX_DIST) {
                        // Fundo Estrelado Simples
                        float stars = pow(fract(sin(dot(rd, vec3(12.9898,78.233,45.543))) * 43758.5453), 20.0);
                        col = vec3(stars);
                        break;
                    }
                }

                // Combina o buraco negro com o brilho acumulado do disco
                col += accDisk;

                // Tone Mapping simples (evita cores estouradas)
                col = col / (1.0 + col);

                gl_FragColor = vec4(col, 1.0);
            }
        `;

        // --- INICIALIZAÇÃO JS ---

        function init() {
            const container = document.getElementById('container');

            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setPixelRatio(1); // Mantém leve para o celular
            renderer.setSize(window.innerWidth, window.innerHeight);
            container.appendChild(renderer.domElement);

            scene = new THREE.Scene();
            
            // Usamos uma câmera ortográfica dummy apenas para renderizar o quadrado da tela
            // A câmera "real" é calculada matematicamente dentro do Shader
            const dummyCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

            const geometry = new THREE.PlaneGeometry(2, 2);
            material = new THREE.ShaderMaterial({
                vertexShader: vertexShader,
                fragmentShader: fragmentShader,
                uniforms: {
                    time: { value: 0 },
                    resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                    camPos: { value: new THREE.Vector3(0, 0, 20) },
                    camTarget: { value: new THREE.Vector3(0, 0, 0) }
                }
            });

            const mesh = new THREE.Mesh(geometry, material);
            scene.add(mesh);

            // Listeners
            window.addEventListener('resize', onWindowResize, false);
            setupControls();

            // Inicia loop
            animate();
        }

        function onWindowResize() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            material.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
        }

        // --- CONTROLES DE TOQUE (ZOOM E ROTAÇÃO) ---
        function setupControls() {
            const el = document.getElementById('container');

            // --- PC (Mouse) ---
            el.addEventListener('mousedown', e => { isDragging = true; lastX = e.clientX; lastY = e.clientY; });
            window.addEventListener('mouseup', () => isDragging = false);
            window.addEventListener('mousemove', e => {
                if(isDragging) handleRotate(e.clientX, e.clientY);
            });
            el.addEventListener('wheel', e => {
                camDist += e.deltaY * 0.01;
                camDist = Math.max(5.0, Math.min(40.0, camDist)); // Limites do zoom
            });

            // --- MOBILE (Touch) ---
            el.addEventListener('touchstart', e => {
                if(e.touches.length === 1) {
                    isDragging = true;
                    isZooming = false;
                    lastX = e.touches[0].clientX;
                    lastY = e.touches[0].clientY;
                } else if(e.touches.length === 2) {
                    isZooming = true;
                    isDragging = false;
                    // Calcula distância inicial entre os dedos
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    lastDist = Math.sqrt(dx*dx + dy*dy);
                }
            }, { passive: false });

            el.addEventListener('touchmove', e => {
                e.preventDefault(); // Impede scroll da tela
                
                if(isDragging && e.touches.length === 1) {
                    handleRotate(e.touches[0].clientX, e.touches[0].clientY);
                } 
                else if(isZooming && e.touches.length === 2) {
                    // Lógica de Zoom (Pinça)
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const currentDist = Math.sqrt(dx*dx + dy*dy);
                    
                    const delta = lastDist - currentDist;
                    camDist += delta * 0.05; // Sensibilidade do zoom
                    camDist = Math.max(5.0, Math.min(40.0, camDist)); // Limites
                    
                    lastDist = currentDist;
                }
            }, { passive: false });

            window.addEventListener('touchend', () => { isDragging = false; isZooming = false; });
        }

        function handleRotate(x, y) {
            const dx = x - lastX;
            const dy = y - lastY;
            
            camLon -= dx * 0.005;
            camLat += dy * 0.005;
            
            // Trava para não virar a câmera de cabeça para baixo totalmente
            camLat = Math.max(-1.5, Math.min(1.5, camLat));
            
            lastX = x;
            lastY = y;
        }

        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now() * 0.001;
            material.uniforms.time.value = time;

            // Atualiza posição da câmera com base na rotação e zoom
            // Converte coordenadas esféricas (lat, lon, dist) para cartesianas (x, y, z)
            const cx = camDist * Math.cos(camLat) * Math.sin(camLon);
            const cy = camDist * Math.sin(camLat);
            const cz = camDist * Math.cos(camLat) * Math.cos(camLon);

            material.uniforms.camPos.value.set(cx, cy, cz);

            renderer.render(scene, camera); // Na verdade renderiza o "dummyCam"
        }

        init();
    </script>
</body>
</html>
