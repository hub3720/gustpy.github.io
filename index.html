<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>Flight Simulator - Global Halo</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: sans-serif; }
        #ui { position: absolute; top: 20px; left: 20px; color: #FFF; pointer-events: none; text-shadow: 2px 2px 4px #000; z-index: 10; }
        .info { font-size: 18px; font-weight: bold; margin-bottom: 5px; }
        #joy-wrapper { position: absolute; bottom: 30px; left: 30px; width: 140px; height: 140px; background: rgba(255,255,255,0.1); border-radius: 50%; border: 2px solid #FFF; touch-action: none; }
        #joy-stick { position: absolute; width: 50px; height: 50px; background: #FFF; border-radius: 50%; top: 45px; left: 45px; }
        .thr-box { position: absolute; bottom: 30px; left: 200px; display: flex; flex-direction: column; align-items: center; color: #FFF; }
        input[type=range] { -webkit-appearance: slider-vertical; width: 30px; height: 140px; }
        .controls { position: absolute; bottom: 20px; right: 20px; }
        button { padding: 12px 20px; cursor: pointer; background: rgba(255,255,255,0.2); color: #FFF; border: 2px solid #FFF; font-weight: bold; }
    </style>
</head>
<body>

    <div id="ui">
        <div class="info" id="ui-spd">SPEED: 0 kts</div>
        <div class="info" id="ui-alt">ALTITUDE: 0 m</div>
    </div>

    <div class="controls"><button id="btn-engine">TURN ON</button></div>
    <div class="thr-box"><b>THR</b><input type="range" id="input-thr" min="0" max="1" step="0.01" value="0"></div>
    <div id="joy-wrapper"><div id="joy-stick"></div></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/examples/jsm/loaders/GLTFLoader": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000005); // Espaço escuro
        
        const renderer = new THREE.WebGLRenderer({ antialias: true, logarithmicDepthBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 10000000);
        
        const sun = new THREE.DirectionalLight(0xffffff, 2.0);
        sun.position.set(5000, 10000, 5000);
        scene.add(sun);
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));

        // PLANETA
        const planetRadius = 637100; 
        const planetGroup = new THREE.Group();
        scene.add(planetGroup);

        const planetGeo = new THREE.SphereGeometry(planetRadius, 128, 128);
        const planetMat = new THREE.MeshStandardMaterial({ color: 0x154515 });
        const planet = new THREE.Mesh(planetGeo, planetMat);
        planetGroup.add(planet);

        // HALO DA ATMOSFERA (3 faixas simuladas por camadas de brilho)
        function createAtmosphere(radius, color, opacity, scale) {
            const geo = new THREE.SphereGeometry(radius * scale, 128, 128);
            const mat = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: opacity,
                side: THREE.BackSide // Visível por dentro e contorno
            });
            return new THREE.Mesh(geo, mat);
        }

        const atm1 = createAtmosphere(planetRadius, 0x00aaff, 0.15, 1.01); // Faixa baixa
        const atm2 = createAtmosphere(planetRadius, 0x0066ff, 0.10, 1.02); // Faixa média
        const atm3 = createAtmosphere(planetRadius, 0x0033ff, 0.05, 1.05); // Faixa alta/Halo
        planetGroup.add(atm1, atm2, atm3);

        planetGroup.position.y = -planetRadius;

        // PISTA (1000x100)
        const runwayGeo = new THREE.BoxGeometry(100, 1, 1000);
        const runwayMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
        const runway = new THREE.Mesh(runwayGeo, runwayMat);
        runway.position.set(0, 0.1, 450); // Posicionada para o avião spawnar nela
        scene.add(runway);

        // Faixas da pista
        const lineGeo = new THREE.PlaneGeometry(2, 20);
        const lineMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        for(let i=0; i<10; i++) {
            const line = new THREE.Mesh(lineGeo, lineMat);
            line.rotation.x = -Math.PI/2;
            line.position.set(0, 0.65, i * 100);
            scene.add(line);
        }

        // AVIÃO
        const planeGroup = new THREE.Group();
        const modelInner = new THREE.Group();
        planeGroup.add(modelInner);

        const cameraAnchor = new THREE.Object3D();
        cameraAnchor.position.set(0, 7, -25);
        planeGroup.add(cameraAnchor);

        let speed = 0, engine = false, thr = 0, joy = { x: 0, y: 0 };

        new GLTFLoader().load('1.glb', (gltf) => {
            gltf.scene.rotation.y = Math.PI;
            gltf.scene.traverse(n => { if(n.isMesh) n.castShadow = true; });
            modelInner.add(gltf.scene);
        });

        scene.add(planeGroup);
        planeGroup.position.set(0, 1.2, 0); // Spawn em cima da pista

        // CONTROLES (Mantidos)
        const stick = document.getElementById('joy-stick'), wrap = document.getElementById('joy-wrapper');
        wrap.onpointermove = (e) => {
            if (e.buttons === 1) {
                const r = wrap.getBoundingClientRect();
                joy.x = ((e.clientX - r.left - 70) / 70) * 0.7; 
                joy.y = ((e.clientY - r.top - 70) / 70) * 0.7;  
                stick.style.transform = `translate(${joy.x * 60}px, ${joy.y * 60}px)`;
            }
        };
        wrap.onpointerup = () => { joy = { x: 0, y: 0 }; stick.style.transform = `translate(0,0)`; };
        document.getElementById('btn-engine').onclick = (e) => { engine = !engine; e.target.innerText = engine ? "OFF" : "ON"; };
        document.getElementById('input-thr').oninput = (e) => thr = parseFloat(e.target.value);

        const clock = new THREE.Clock();
        const tempVec = new THREE.Vector3();

        function loop() {
            const dt = clock.getDelta();
            
            // Calculo de altitude relativo à superfície da esfera
            const distToCenter = planeGroup.position.distanceTo(planetGroup.position);
            const currentAlt = distToCenter - planetRadius;
            const isGrounded = currentAlt <= 1.3;

            // Ajuste de Céu (Ciano quando baixo, Preto quando alto)
            let skyFactor = THREE.MathUtils.clamp(currentAlt / 20000, 0, 1);
            let skyCol = new THREE.Color(0x80dfff).lerp(new THREE.Color(0x000000), skyFactor);
            scene.background = skyCol;

            // FÍSICA
            let speedLimit = (currentAlt > 1000) ? 800 : 250;
            speed = THREE.MathUtils.lerp(speed, engine ? thr * speedLimit : 0, dt * 0.5);

            if (isGrounded) {
                planeGroup.position.y = THREE.MathUtils.lerp(planeGroup.position.y, 1.2, dt * 5);
                planeGroup.rotation.y -= joy.x * dt * 0.8;
                planeGroup.rotation.x = THREE.MathUtils.lerp(planeGroup.rotation.x, 0, dt * 2);
                planeGroup.rotation.z = THREE.MathUtils.lerp(planeGroup.rotation.z, 0, dt * 2);

                if (speed > 130 && joy.y < -0.2) { // Puxar manche para subir
                    planeGroup.position.y += 2 * dt; 
                }
            } else {
                planeGroup.rotation.x = THREE.MathUtils.lerp(planeGroup.rotation.x, joy.y * 0.8, dt * 1.5);
                planeGroup.rotation.z = THREE.MathUtils.lerp(planeGroup.rotation.z, -joy.x * 0.8, dt * 1.5);
                planeGroup.rotation.y -= planeGroup.rotation.z * dt * 0.5;

                const lift = (speed / 180) * (1 + planeGroup.rotation.x);
                planeGroup.position.y += (lift - 1.0) * 50 * dt;
                
                // Simulação de gravidade/curvatura simples
                if (currentAlt > 1000) {
                     // Atração para o centro do planeta
                     const dirToCenter = new THREE.Vector3().subVectors(planetGroup.position, planeGroup.position).normalize();
                     planeGroup.position.addScaledVector(dirToCenter, dt * 5);
                }
            }

            planeGroup.translateZ(speed * dt);

            // CÂMERA
            cameraAnchor.getWorldPosition(tempVec);
            camera.position.lerp(tempVec, 0.1);
            camera.lookAt(planeGroup.position);

            // UI
            document.getElementById('ui-spd').innerText = `SPEED: ${Math.round(speed)} kts`;
            document.getElementById('ui-alt').innerText = `ALTITUDE: ${Math.max(0, Math.round(currentAlt))} m`;

            renderer.render(scene, camera);
            requestAnimationFrame(loop);
        }

        loop();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
